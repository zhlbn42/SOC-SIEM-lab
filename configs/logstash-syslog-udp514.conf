input {
  udp {
    port => 5514
    type => "syslog"
  }
}

filter {
  # Общий grok для syslog
  if [type] == "syslog" {
    grok {
      match => {
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{HOSTNAME:hostname} %{DATA:program}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:msg}"
      }
      tag_on_failure => ["_grok_failed_syslog"]
    }
  }

  # Сохраняем исходное сообщение
  if [message] and ![msg] { mutate { add_field => { "msg" => "%{message}" } } }

  # Best effort parsing for sshd auth lines (optional)
  grok {
    match => {
      "msg" => [
        "Failed password for %{USERNAME:tmp_user} from %{IP:tmp_src_ip} port %{NUMBER:tmp_src_port} ssh2",
        "Accepted password for %{USERNAME:tmp_user} from %{IP:tmp_src_ip} port %{NUMBER:tmp_src_port} ssh2"
      ]
    }
    tag_on_failure => ["_grok_failed_sshd"]
  }

  # Map to ECS-ish fields (nice for grouping later)
  if [tmp_src_ip] {
    mutate {
      add_field => {
        "[source][ip]" => "%{tmp_src_ip}"
        "[user][name]" => "%{tmp_user}"
      }
    }
  }

  mutate { remove_field => ["tmp_src_ip","tmp_user","tmp_src_port"] }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    user => "elastic"
    password => "KA8O1j9*NYWUVwNAne5+"
    index => "metasploitable-%{+YYYY.MM.dd}"
    # NOTE: auth is configured locally (do not commit creds)
  }
}
